#!/usr/bin/env bash

shopt -s extglob

# Squelch ShellCheck warning (https://github.com/koalaman/shellcheck/wiki/SC1090):
# shellcheck source=/dev/null
source "${XDG_CONFIG_HOME:-$HOME/.config}/signal/init.bash"

[[ ! $signal_cli ]] && signal_cli='signal-cli'

show-help() {
cat << EOF
Usage: ${0##*/} [-ad]
Start signal-cli in daemon mode and creates notifications for incoming
messages using notify-send.

  -h  display this help and exit
  -a  show avatars in notifications
  -d  print debugging output
EOF
}

declare -i debug=0 show_avatars=0

# http://mywiki.wooledge.org/BashFAQ/035#getopts
# http://wiki.bash-hackers.org/howto/getopts_tutorial
while getopts ':had' opt; do
   case $opt in
      h)
         show-help
         exit
         ;;
      a)
         show_avatars=1
         ;;
      d)
         (( ++debug ))
         ;;
   esac
done
shift "$((OPTIND-1))" # Shift off the options and optional --.

start-daemon() {
   "$signal_cli" -u "$user" daemon
}

notify() {
   # Replace consecutive newlines with null ('\0').  The use of `fflush()` is essential.
   # It forces gawk to flush stdout.  Without it, gawk buffers its output.  See
   # <http://mywiki.wooledge.org/BashFAQ/009>.
   gawk -v RS='\n\n' -v ORS='\0' '{ print; fflush(stdout) }' |
   # This method (`RS=`) doesn't work with gawk, but should with Plan 9 awk:
   # /opt/plan9/bin/awk -v RS= -v ORS='\0' '{ print; fflush() }' |
   while IFS= read -r -d '' message; do
      (( debug )) && echo "$message"$'\n'
      # Remove any empty lines at the start of the message.  These may exist when the
      # previous messages body had a trailing empty line (or several).
      message=${message##*($'\n')}
      if [[ ${message%%$'\n'*} == *${user}* ]]; then
         # The first line of the message contains the users phone number; i.e., it's from
         # the user.  Don't do anything with it.
         continue
      fi
      # The message body extends to the end of the message or until we encounter an
      # "Attachments: " or "Group info:" section.
      pattern=$'*\nBody: *'
      [[ $message != $pattern ]] && continue
      body=${message#*$'\nBody: '}
      body=${body%$'\nAttachments: \n'*}
      body=${body%$'\nGroup info:\n'*}
      attachment=
      if [[ $message =~ $'\nAttachments: \n- ' ]]; then
         file=${message##*$'\n'  Stored plaintext in: }
         # Check if a prefix string was removed by comparing string lengths.
         if (( ${#file} != ${#message} )); then
            attachment=" (file://$file)"
         # else
            # attachment="\n<b>Unknown attachments</b>"
         fi
      fi
      timestamp=${message##*$'\n'Message timestamp: }
      # The (Unix time) timestamps used have 13 digits.  The last 3 are milliseconds.
      timestamp=${timestamp:0:13}
      # The format `date` expects is '@1234567890.123'.
      timestamp=$(date -d "@${timestamp:0:10}.${timestamp:11}" '+%H:%M')
      # Remove a single trailing space if there is one.
      body=${body/% }
      # Get the first line.
      head=${message%%$'\n'*}
      # Remove 'Envelope from: ' from the line's start.
      from_info=${head#Envelope from: }
      # If nothing was removed (the first line doesn't start with 'Envelope from: '), give
      # up on this message.  TODO: is there a better way to check this?
      [[ "$from_info" == "$head" ]] && continue
      # Remove the closing quote mark (”) and everything following it.
      sender=${from_info%%”*}
      if [[ "$sender" != "$from_info" ]]; then
         # It worked: some substring was removed by the parameter expansion.
         sender=${sender#“} # Remove the quote mark before the name.
         # Remove the closing quote make and everything before it.
         number=${from_info##*” }
         # Remove everything following the first space character.
         number=${number%% *}
            # Remove the first space character and everything following it.  I.e., only
            # keep the first name.
            # sender=${sender%% *}
      else
         # The message didn't contain a name: use the phone number.
         sender=${sender%% *} # Remove everything following the first space character.
         number=$sender
      fi
      [[ ! $sender ]] && continue
      # Declare empty or empty existing array.
      options=()
      if (( show_avatars )); then
         # Grab the the avatar icon.
         icon=${XDG_CONFIG_HOME:-$HOME/.config}/signal/avatars/contact-${number}
         if [[ -f $icon ]]; then
            options+=(-i $icon)
         fi
      fi
      group_name=
      pattern=$'*\nGroup info:\n  Id: *\n  Name: '
      if [[ $message == $pattern* ]]; then
         group_name=${message##$pattern}
         group_name=${group_name%%$'\n'*}
      fi
      notification="<b>$timestamp</b> ${sender}"
      notification+="${group_name:+ ($group_name)}:${body:+ $body}$attachment"
      if [[ $group_name ]]; then
         options+=(-u low)
      else
         options+=(-h 'string:bgcolor:#d70087')
      fi
      notification="<b>$timestamp</b> $sender"
      # XXX: this is kind of neat.
      # body=$(trans -b :en "$body")
      # XXX: listen to the translation.
         # body="$(trans -b -p :en "$body" 2>/dev/null)" # this breaks
      # body=$(trans -b -p :en <<< "$body" 2>/dev/null)
      notification+="${group_name:+ ($group_name)}:${body:+ $body}$attachment"
      # if [[ $group_name ]]; then
      #    notify-send -a 'signal-cli' -u low "$notification"
      # else
      #    notify-send -a 'signal-cli' -h 'string:bgcolor:#d70087' "$notification"
      # fi
      # set -x
      notify-send -a 'signal-cli' "${options[@]}" "$notification"
      # set +x
   done
}

# If there are more positional parameters, assume they name test input files and pipe
# their contents into `notify`.  Normally, start `signal-cli` in daemon mode and pipe its
# output into `notify`.
if [[ $1 ]]; then cat "$@" -; else start-daemon; fi | notify

# vim: tw=90 sts=-1 sw=3 et
